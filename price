#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say);

use Getopt::Long;
use Mojo::DOM;
use Mojo::UserAgent;

use Data::Dumper;

my $MAX_INTER             = 2;
my $MAX_INTER_LENGTH      = 1;
my $MAX_INNER_WORD_COUNT = 1;
my $MAX_OCCURENCE_PERC    = 90;

my $PRICE_RE = qr/
   (?<i> (?&FLOAT) ) (?<u> (?&UNITS) )?
   (?&PAD) (?<r> (?&RANGE) ) (?&PAD)
   (?(<r>)
      (?<ii> (?&FLOAT) )?
      (?(<ii>)
         (?<u> (?&UNITS) )?
      )
   )
   (?(DEFINE)
      (?<FLOAT> \d+ (?: [.,] \d+ )? )
      (?<PAD> \s* )
      (?<RANGE> [-] )

      (?<DOLLAR> $ | &dollar; | (?i: dollar(?:s)? ) )
      (?<EURO> â‚¬ | &euro; | (?i: euro(?:s)? ) )
      # define units here

      (?<UNITS>
           (?&DOLLAR) 
         | (?&EURO)
         # more units
      )
   )
/x;

sub generate_article_regex {
   my $article = shift;
   my @token_re;

   foreach my $token (split m/\s+/, $article) {
      my $re = q{ (?<=\s) ( };

      if (length $token > 1) {
         $re .= join ' ', map "(?<c>$_)? (?<i>.*?)", (split '', $token)[0..length($token) - 2];
         $re .= q{ (?<c>} . chop($token) . q{)?};
      }
      else {
         $re .= "(?<c>$token)";
      }
      push @token_re, qr/$re (?=\s) ) /x
   }

   return join ' (?<words>.*?) ', @token_re
}

sub apply_edit_distance {
   my ( $token_re, $article, $tags_content ) = @_;

   while ( $tags_content =~ m/$token_re/gso ) {

      foreach my $inner_words ( grep { defined } $+{words}->@* ) {
         next 2 if ($inner_words =~ m/(?<=\s{0,1})(\S+)(?=\s{0,1})/g) > $MAX_INNER_WORD_COUNT;
      }

      if ( ( $+{c}->@* / length $article ) * 100 < $MAX_OCCURENCE_PERC )
      || ( grep { defined } $+{i}->@* > $MAX_INTER )
      || ( grep { defined && length > $MAX_INTER_LENGTH } $+{i}->@* ) {
         next
      }

      push @target_article, [
         $1,               # article name we got
         scalar $+{i}->@*, # unknown chars
         scalar $+{c}->@*, # known
      ]
   }

   return ( sort { } @target_article )[0][0];
}
