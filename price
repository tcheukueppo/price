#!/usr/bin/env perl

use strict;
use warnings;
use feature qw(say);

use Getopt::Long;
use Mojo::DOM;
use Mojo::UserAgent;

use Data::Dumper;

my $MAX_INTER            = 2;
my $MAX_INTER_LENGTH     = 1;
my $MAX_INNER_WORD_COUNT = 1;
my $MAX_OCCURENCE_PERC   = 90;

my $PRICE_RE = qr/
   (?<i> (?&FLOAT) ) (?<u> (?&UNITS) )?
   (?&PAD) (?<r> (?&RANGE) ) (?&PAD)
   (?(<r>)
      (?<ii> (?&FLOAT) )?
      (?(<ii>)
         (?<u> (?&UNITS) )?
      )
   )
   (?(DEFINE)
      (?<FLOAT> \d+ (?: [.,] \d+ )? )
      (?<PAD> \s* )
      (?<RANGE> [-] )

      (?<DOLLAR> $ | &dollar; | (?i: dollar(?:s)? ) )
      (?<EURO> â‚¬ | &euro; | (?i: euro(?:s)? ) )
      # define units here

      (?<UNITS>
           (?&DOLLAR) 
         | (?&EURO)
         # more units
      )
   )
/x;

sub generate_article_regex {
    my $article       = shift;
    my $capture_index = -1;
    my @token_re;

    foreach my $token ( split m/\s+/, $article ) {
        my $token_re = ' (?<=\s) ( ';

        $capture_index++;
        if ( length $token > 1 ) {
            $token_re .= join ' ',
                map "(?<c_${capture_index}>$_)? (?<i_${capture_index}>.*?)",
                ( split '', $token )[ 0 .. length( $token ) - 2 ];
            $token_re .= " (?<c_${capture_index}>" . chop( $token ) . ')?';
        }
        else {
            $token_re .= "(?<c_${capture_index}>$token)";
        }

        push @token_re, qr/ $token_re ) (?=\s) /x;
    }

    return {
        max_capture_index => $capture_index,
        regex             => '(' . join( ' (?<words>.*?) ', @token_re ) . ')'
    };
}

sub apply_edit_distance {
    my ( $token_re, $article, $tags_content, $config ) = @_;
    my ( $nwords, $total_i, $total_c );
    my @target_article;

    while ( $tags_content =~ m/$token_re->{regex}/gso ) {
        ( $nwords, $total_i, $total_c ) = ();

        foreach my $inner_words ( grep { defined } $-{words}->@* ) {
            $nwords = () = $inner_words =~ m/ (?<=\s{0,1}) (\S+) (?=\s{0,1}) /gx;
            if ( $nwords > $config{MAX_WORD_COUNT_BETWEEN} ) {
               pos $token_re->{regex} = #val;
               next 2;
            }
        }


        foreach my $cap_index ( 1 .. $token_re->{max_capture_index} ) {
           my $i = $-{ 'i_' . $token_re->{max_capture_index} } // [];
           my $c = $-{ 'c_' . $token_re->{max_capture_index} } // [];

           # Avoid a single token 
           if (   ( ( @$c / length $article ) * 100 < $config{MAX_OCCURENCE_PERC} )
               || ( grep { defined } @$i > $MAX_INTER )
               || ( grep { defined && length > $config{MAX_INTER_LENGTH} } @$i ) ) {
               pos $token_re->{regex} = #val;
               next 2;
           }
           $total_i += @$i;
           $total_c += @$c;
        }

        push @target_article, [ $1, $total_i, $total_c, $nwords ];
    }

    return ( sort { $a->[ 3 ] <=> $b->[ 3 ] || $a->[ 2 ] <=> $b->[ 2 ] || $a->[ 1 ] <=> $b->[ 1 ] } @target_article )[ @target_article ][ 0 ];
}

say Dumper generate_article_regex( 'I love perl' );
